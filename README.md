# Otus
Домашние задания по курсу [Архитектор ПО](https://otus.ru/lessons/arhitektor-po/?int_source=courses_catalog&int_term=operations)

## Первое домашнее задание
**tag**: v0.0.1 

Обернуть приложение в docker-образ и запушить его на Dockerhub
Создать минимальный сервис, который
1) отвечает на порту 8000
2) имеет http-метод
GET /health/
RESPONSE: {"status": "OK"}

Cобрать локально образ приложения в докер.
Запушить образ в dockerhub

На выходе необходимо предоставить
1) имя репозитория и тэг на Dockerhub
[jawello/otus:0.0.1](https://hub.docker.com/repository/docker/jawello/otus)
2) ссылку на github c Dockerfile, либо приложить Dockerfile в ДЗ

## Второе домашнее задание
**tag**: v0.0.2

Развернуть приложение в minikube

**Цель:** Написать манифесты для деплоя в k8s для сервиса из прошлого 
ДЗ. 
Манифесты должны описывать сущности Deployment, Service, Ingress. 
В Deployment обязательно должны быть указаны Liveness, Readiness пробы. 
Количество реплик должно быть не меньше 2. Image контейнера должен быть 
указан с Dockerhub. В Ingress-е должно быть правило, которое форвардит 
все запросы с /otusapp/* на сервис с rewrite-ом пути. Хост в ингрессе 
должен быть arch.homework. В итоге после применения манифестов GET 
запрос на http://arch.homework/otusapp/health должен отдавать
`{“status”: “OK”}`. На выходе предоставить ссылку на github c 
манифестами. 
Манифесты должны лежать в одной директории, так чтобы можно было их все 
применить одной командой kubectl apply -f .

## Третье домашнее задание
**tag**: v0.0.3

Добавить к развернутому приложению БД.
Сделать простейший RESTful CRUD по созданию, удалению, просмотру и 
обновлению пользователей.
Пример API - https://app.swaggerhub.com/apis/otus55/users/1.0.0

Добавить базу данных с persistent volume для приложения.
Docker-Image базы данных должен использоваться из официального 
докер-репозитория.
Под с БД должен запускаться StatefulSet-ом с количеством реплик - 1.
Конфигурация приложения должна хранится в Configmaps.
Доступы к БД должны храниться в Secrets.
Первоначальные миграции должны быть оформлены в качестве Pod-ы 
(или Job-ы).
Ingress-ы должны также вести на url arch.homework/otusapp/* 
(как и в прошлом занятии)

На выходе должны быть предоставлена
1) ссылка на директорию в github, где находится директория с манифестами
кубернетеса
2) команда kubectl apply -f, которая запускает в правильном порядке
манифесты кубернетеса.
3) Postman коллекция, в которой будут представлены примеры запросов к
сервису на создание, получение, изменение и удаление пользователя. 
Запросы из коллекции должны работать сразу после применения манифестов, 
без каких-то дополнительных подготовительных действий.

**tag**: v0.0.4

Задание со звездочкой (необязательное, но дает дополнительные баллы):
+3 балла за шаблонизацию приложения в helm 3 чартах
+2 балла за использование официального helm чарта для БД и подключение
его в чарт приложения в качестве зависимости.

## Четвертое домашнее задание
**tag**: v0.0.5

Инструментировать сервис метриками и алертами.
Инструментировать сервис из прошлого занятия метриками в формате 
Prometheus с помощью библиотеки для вашего фреймворка и ЯП.

Сделать дашборд в Графане, в котором были бы метрики с разбивкой по API 
методам:
1. Latency (response time) с квантилями по 0.5, 0.95, 0.99, max
2. RPS
3. Error Rate - количество 500ых ответов

Добавить в дашборд графики с метрикам в целом по сервису, взятые с 
nginx-ingress-controller:
1. Latency (response time) с квантилями по 0.5, 0.95, 0.99, max
2. RPS
3. Error Rate - количество 500ых ответов

Настроить алертинг в графане на Error Rate и Latency.

На выходе должно быть:
1) хелм чарт или директория с манифестами для запуска приложения с нуля.
В этой же директории должны быть servicemonitor-ы. В хелм чарт в 
качестве зависимостей не надо устанавливать nginx-ingress-controller и 
прометеус-оператор. Считаем, что они уже в кубике установлены.
В случае использования хелма без шаблонизации, отдельно про это написать
и указать команду установки через хелм и имя релиза.
2) в этой же директории dashboard.yaml - манифест с конфигмапом дашборды
для графаны, в формате, который умеет автоматически применять 
prometheus-operator
3) отдельно stresstest.yaml - манифсет с Job-ой, которая производит 
стабильную (не больше 20 и не меньше 5 рпс), нагрузку на все API методы,
в бесконечном цикле. Для нагрузки надо делать запросы на 
ingress-controller, передавая значение имени сервиса, на котором живет 
ингресс-контроллер в переменной окружения, и в случае использования helm
в качестве value-значения.
4) скриншоты дашборды в момент стресс-тестирования сервиса. Например,
после 5-10 минут нагрузки.


Задание со звездочкой (+5 баллов)
Инструментировать базу данных с помощью экспортера для prometheus для
этой БД.
Добавить в общий дашборд графики с метриками работы БД.

Используя существующие системные метрики из кубернетеса, добавить на 
дашборд графики с метриками:
1. Потребление подами приложения памяти
2. Потребление подами приолжения CPU

### Дополнение
Все команды выполняются из root'овой директории проекта.
#### Команда для установки prometheus
```bash
helm install prom stable/prometheus-operator -f prometheus/prometheus.yaml --atomic
```
#### Команда для установки nginx-controller
```bash
helm install nginx stable/nginx-ingress -f prometheus/nginx-ingress.yaml --atomic
```
#### Команда для добавления dashboard'а в grafan'у (имя dashboard'а "Service") 
```bash 
kubectl apply -f prometheus/grafana.yaml 
```
#### Команда для запуска стресс-теста
```bash
skaffold run -f stresstest.skaffold.yaml 
```
Параметры запуска stresstest'а находятся в stresstest-chart/values.yaml.
Это параметры для запуска 
[locust'а](https://docs.locust.io/en/stable/configuration.html) . 

## Пятое домашнее задания
**tag**: v0.0.6
Реализовать клиентскую аутентификацию и авторизацию с помощью apigateway.
Добавить в приложение аутентификацию и регистрацию пользователей.

Реализовать сценарий "Изменение и просмотр данных в профиле клиента".
Пользователь регистрируется. Заходит под собой и по определенному урлу 
получает данные о своем профиле. Может поменять данные в профиле. Данные
профиля для чтения и редактирования не должны быть доступны другим 
клиентам (аутентифицированным или нет).

На выходе должны быть
1. описание архитектурного решения и схема взаимодействия сервисов (в 
виде картинки)
1. команда установки приложения (из helm-а или из манифестов). 
Обязательно указать в каком namespace нужно устанавливать.
1. команда установки api-gateway, если он отличен от nginx-ingress.
1. тесты постмана, которые прогоняют сценарий:
    - регистрация пользователя 1
    - проверка, что изменение и получение профиля пользователя 
    недоступно без логина
    - вход пользователя 1
    - изменение профиля пользователя 1
    - проверка, что профиль поменялся
    - выход* (если есть)
    - регистрация пользователя 2
    - вход пользователя 2
    - проверка, что пользователь2 не имеет доступа на чтение и 
    редактирование профиля пользователя1.

В тестах обязательно
- наличие {{baseUrl}} для урла
- использование домена arch.homework в качестве initial значения 
{{baseUrl}}
- использование сгенерированных случайно данных в сценарии
- отображение данных запроса и данных ответа при запуске из командной 
строки с помощью newman.
### Архитектура

### Дополнение
Все команды выполняются из root'овой директории проекта.
#### Команда для запуска приложения
```bash
skaffold run -f otus-app.skaffold.yaml
```
или
```bash
helm install otus-app otus-app/otus-app-chart  
```
#### Команда для запуска сервиса аутентификации
```bash
skaffold run -f otus-auth.skaffold.yaml  
```
или
```bash
helm install otus-auth otus-auth/otus-auth-chart  
```
#### Команды для добавления ingress'ов
```bash 
kubectl apply -f otus-auth/app-ingress.yaml 
kubectl apply -f otus-auth/auth-ingress.yaml           
```
#### Команда для запуска теста
```bash
newman run otus-auth/otus-app-auth.postman_collection.json
```